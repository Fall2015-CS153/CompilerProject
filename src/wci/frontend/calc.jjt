options{
    NODE_EXTENDS="wci.intermediate.icodeimpl.ICodeNodeImpl";
    MULTI=true;
    VISITOR=true;
}
PARSER_BEGIN(ExprParser)
package wci.frontend;

import java.util.ArrayList;
import java.io.*;

import wci.intermediate.*;
import wci.intermediate.symtabimpl.*;
import wci.backend.*;
import wci.util.*;

import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.symtabimpl.DefinitionImpl.*;
import static wci.intermediate.symtabimpl.RoutineCodeImpl.*;
import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
import static wci.intermediate.icodeimpl.ICodeKeyImpl.*;

public class ExprParser
{
    private static SymTabStack symTabStack;
    private static SymTabEntry programId;
    private static int index=0;

    public static void main(String[] args)
        throws Exception
    {
    	// Create and initialize the symbol table stack.
        symTabStack = SymTabFactory.createSymTabStack();
        Predefined.initialize(symTabStack);

 // Parse a Pcl program.
        Reader    reader = new FileReader(args[0]);
        ExprParser parser = new ExprParser(reader);
        SimpleNode rootNode = parser.Program();

        // Print the cross-reference table.
        CrossReferencer crossReferencer = new CrossReferencer();
        crossReferencer.print(symTabStack);

        // Visit the parse tree nodes to decorate them with type information.
        ExprParserVisitorAdapter typeVisitor = new ExprParserVisitorAdapter();
        rootNode.jjtAccept(typeVisitor, null);

        // Create and initialize the ICode wrapper for the parse tree.
        ICode iCode = ICodeFactory.createICode();
        iCode.setRoot(rootNode);
        programId.setAttribute(ROUTINE_ICODE, iCode);
        
        // Print the parse tree.
        ParseTreePrinter treePrinter = new ParseTreePrinter(System.out);
        treePrinter.print(symTabStack);

}


    }

PARSER_END(ExprParser)

SKIP : {
   <IGNORE : [" " , "\n"]> |
   <SINGLELINECOMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| < NEWLINE: ["\n", "\r"] >
}
SKIP :
{
  "/*" : WithinComment

}
<WithinComment> SKIP :
{
  "*/" : DEFAULT

}

<WithinComment> MORE :
{
  <~[]>
}

TOKEN:
{

<SPECIALSYMBOL: "~"  | "@" | "%" | "^" |
 "?"  | "." | "\'"  | "<<" | ">>" | "|=" | "%="|
"&=" | "^="   | "<<=" | ">>=" |"\""   >

|
<SSAnd: "&">

|
<SSOr: "|">

|
<SSNot: "!">

|
<SSL: "<">

|
<SSLE: "<=">

|
<SSG: ">">

|
<SSGE: ">=">

|
<SSNE: "!=">

|
<SSPlus: "+">

|
<SSMinus: "-">

|
<SSStar: "*">

|
<SSDivide: "/">

|
<SSplusplus: "++">

|
<SSminusminus: "--">

|
<SSSemiColon: ";">

|
<SSPlusEquals: "+=">

|
<SSMinusEquals: "-=">

|
<SSMultEquals: "*=">

|
<SSDivideEquals: "/=">

|
<SSEquals: "=">

|

<SSOpenParen : "(">

|
<SSCloseParen : ")">

|
<SSOpenBraces : "{">

|
<SSCloseBraces : "}">

|
<SSOpenBracket : "[">

|
<SSCloseBracket : "]">

|
<ComparisonEquals : "==">

|
<SSComma : ",">

|
<SSColon : ":">

}

TOKEN : {
 <RESERVEDWORDPROCEDURE :"Procedure ::">

| <RESERVEDWORDIF :"if">

 |<RESERVEDWORDBREAK :"break">

 |<RESERVEDWORDELSE :"else">

 |<RESERVEDWORDELSEIF :"elseif">

 |<RESERVEDWORDRETURN :"return">

 |<RESERVEDWORDCASE :"case">

|<RESERVEDWORDSWITCH :"switch">

|<RESERVEDWORDWHILE :"while">

 |<RESERVEDWORDFOR :"for">

 |<RESERVEDWORDTRUE :"true">

 |<RESERVEDWORDFALSE :"false">

|<RESERVEDWORDINT :"int">

 |<RESERVEDWORDFLOAT :"float">

|<RESERVEDWORDBOOLEAN :"boolean">

|<RESERVEDWORDDOUBLE :"double">

|<RESERVEDWORDSTRING :"string">

|<RESERVEDWORDHASHMAP :"hashmap">

|<RESERVEDWORDSET :"set">

 |<RESERVEDWORDLIST :"list">

 |<RESERVEDWORDNEW :"new">


| <IDENTIFIER : <LETTER> (<LETTER> | <DIGIT> )*>
|<STRING:(<SINGLEQUOTE>|<DOUBLEQUOTE>)(<LETTER>|<DIGIT>|(<IGNORE>)*|<SPECIALSYMBOL> |<IGNORE> (<SINGLEQUOTE>|<DOUBLEQUOTE>))*  >
|<INTEGER: <DECIMALINTEGER>|<OCTALINTEGER>|<HEXINTEGER>>
| <DECIMALINTEGER : <NONZERO> (<DIGIT> )*>
| <OCTALINTEGER : <ZERO>(<OCTALS> )*>
| <HEXINTEGER : "0"("x"|"X")(<DIGIT>|<HEXLETTERS>)(<DIGIT>|<HEXLETTERS> )*>
| <REALNUMBER : (<DIGIT>(<DIGIT>)* ("."|"")(<DIGIT>)* ("e"|"E"|"")("+"|"-"|"")(<DIGIT>)*)>
| <REAL_NUMBER : ("."(<DIGIT>)* ("e"|"E"|"")("+"|"-"|"")(<DIGIT>)*)>


 | <#SINGLEQUOTE:["\'"]>
 | <#DOUBLEQUOTE:["\""]>
 | <#HEXLETTERS:["A"-"F","a"-"f"]>
 | <#DIGIT  : ["0"-"9"]>
 | <#NONZERO  : ["1"-"9"]>
 | <#LETTER : ["a"-"z","A"-"Z","_"]>
 | <#OCTALS: ["0"-"7"]>
 | <#ZERO : ["0"]>

}



SimpleNode Program() : {}
{
<RESERVEDWORDPROCEDURE>{
	programId = symTabStack.enterLocal(token.image);
        programId.setDefinition(DefinitionImpl.PROGRAM);
        programId.setAttribute(ROUTINE_SYMTAB, symTabStack.push());
        symTabStack.setProgramId(programId);
	
}<SSOpenBraces> (IfPart() | SwitchPart()|Statement()| DataTypes()|For()|While() )* <SSCloseBraces>
{

return jjtThis;
}

}
TypeSpec PrimitiveType(): {}
{
  <RESERVEDWORDINT> {return Predefined.integerType;}
  |<RESERVEDWORDSTRING>{return Predefined.stringType;}
  |<RESERVEDWORDDOUBLE>{return Predefined.doubleType;}
  |<RESERVEDWORDFLOAT>{return Predefined.floatType;}
  |<RESERVEDWORDBOOLEAN>{return Predefined.booleanType;}


}

void Expr(): {}
{
   SimpleExpr() ( (<SSL>|<SSLE>|<SSG>|<SSGE>|<ComparisonEquals>) SimpleExpr() )*
   


}
void SimpleExpr(): {}
{
  (<SSMinus>)? Term() ((<SSPlus>|<SSMinus>|<SSOr>) Term() )*

}
void Term (): {}
{
  Factor() ( (<SSStar>|<SSDivide>|<SSAnd>) Factor() )*


}

void Factor(): {}
{
    variable()|(IntegerConst()|<REALNUMBER>|<REAL_NUMBER>)|<STRING>|(<SSNot>Factor())| (<SSOpenParen> Expr() <SSCloseParen>) |<RESERVEDWORDTRUE>|<RESERVEDWORDFALSE>
   

}
void Statement(): {}
{
   LOOKAHEAD(3)IncrementStatement()|LOOKAHEAD(3)DecrementStatement()|LOOKAHEAD(3)Assignment()|Declaration()|LOOKAHEAD(2)PlusEqualsStatement()|LOOKAHEAD(2)MinusEqualsStatement()|LOOKAHEAD(2)DivideEqualsStatement()|StarEqualsStatement()



}
void IfPart() : {}
{
  <RESERVEDWORDIF> <SSOpenParen> (Expr()) <SSCloseParen> <SSOpenBraces> (Statement())* <SSCloseBraces> (ElseIfPart())* (ElsePart())?


}

void ElseIfPart() : {}
{
 <RESERVEDWORDELSEIF> <SSOpenParen> (Expr()) <SSCloseParen><SSOpenBraces>  (Statement())* <SSCloseBraces>


}

void ElsePart() : {}
{
 <RESERVEDWORDELSE> <SSOpenBraces>  (Statement())* <SSCloseBraces>


}




void Literal() : {}
{
	IntegerConst()|RealConst()|StringConst()
	

}



void IntegerConst() : {}
{
	<INTEGER>
{
        jjtThis.setTypeSpec(Predefined.integerType);
        jjtThis.setAttribute(VALUE, Integer.parseInt(token.image));
    }
	

}

void RealConst() : {}
{
	<REALNUMBER>|<REAL_NUMBER>
{
        jjtThis.setTypeSpec(Predefined.realType);
        jjtThis.setAttribute(VALUE, Float.parseFloat(token.image));
    }
	

}

void StringConst() : {}
{
	<STRING>
{
        jjtThis.setTypeSpec(Predefined.stringType);
        jjtThis.setAttribute(VALUE, token.image);
    }
	

}




void SwitchPart() : {}
{
     <RESERVEDWORDSWITCH> <SSOpenParen> (variable())<SSComma>(ComparisonOperator()) <SSCloseParen><SSOpenBraces>  (Cases())+ <SSCloseBraces>
	

}
void ComparisonOperator() : {}
{
 <SSAnd>|<SSOr>|<SSNot>|<ComparisonEquals>|<SSL>|<SSLE>|<SSG>|<SSGE>|<SSNE>


}
void Cases() : {}
{
	<RESERVEDWORDCASE> (Expr()) <SSColon> <SSOpenBraces> (LOOKAHEAD(3)Declaration()|Assignment())* <SSCloseBraces>
	

}
void Assignment() : {}
{
  
variable() 
<SSEquals> (Expr()) <SSSemiColon>


}

void variable() : {}
{
    <IDENTIFIER> {
        SymTabEntry variableId = symTabStack.lookup(token.image);
	    if(variableId==null){
		System.out.println("VARIABLE LOOKUP ERROR***");
	    }else {
        variableId.appendLineNumber(token.beginLine);
        TypeSpec type = variableId.getTypeSpec();
        jjtThis.setTypeSpec(type);
        jjtThis.setAttribute(ID, variableId);
	    }
    }
}

void Declaration(): {TypeSpec type;}
{
   type=PrimitiveType()
   <IDENTIFIER>{
       SymTabEntry variableId = symTabStack.enterLocal(token.image);
       variableId.setDefinition(DefinitionImpl.VARIABLE);
       if(type!=null){
           variableId.setTypeSpec(type);
       }else{     
           variableId.setTypeSpec(Predefined.undefinedType);
       }
       variableId.appendLineNumber(token.beginLine);
       variableId.setIndex(index++);
	
   }
   (LOOKAHEAD(2)((<SSEquals> (Expr()) <SSSemiColon>)) |( (<SSComma> <IDENTIFIER>)*  <SSSemiColon> ) )
{
}

}


void IncrementStatement(): {}
{
   variable()<SSplusplus><SSSemiColon>
 

}
void DecrementStatement(): {}
{
   variable()<SSminusminus><SSSemiColon>


}
void PlusEqualsStatement(): {}
{
    variable() <SSPlusEquals>(variable()|IntegerConst()) <SSSemiColon>
}

void MinusEqualsStatement():{}
{
variable() <SSMinusEquals> (variable()|IntegerConst())<SSSemiColon>
}
void StarEqualsStatement(): {}
{
variable() <SSMultEquals> (variable()|IntegerConst())<SSSemiColon>
}
void DivideEqualsStatement(): {}
{
variable() <SSDivideEquals>(variable()|IntegerConst())<SSSemiColon>
}
void For(): {}
{
  <RESERVEDWORDFOR> <SSOpenParen>(Declaration()|Assignment())<SSSemiColon> Expr()<SSSemiColon> Statement()<SSCloseParen><SSOpenBraces> (Statement())* <SSCloseBraces>
}

void While():{}
{
 <RESERVEDWORDWHILE> <SSOpenParen> Expr() <SSCloseParen><SSOpenBraces> (Statement())* <SSCloseBraces>
}

void DataTypes() : {}
{
(Hashmap()| List() | Set())


}
void Hashmap (): {Token t;}
{
 t = <RESERVEDWORDHASHMAP> variable() (<SSOpenBracket> IntegerConst() <SSCloseBracket> <SSEquals> IntegerConst()| <SSEquals><RESERVEDWORDNEW>) <SSSemiColon>
}
void Set (): {Token t;}
{
t =  <RESERVEDWORDSET> variable() (<SSOpenBracket> IntegerConst() <SSCloseBracket> <SSEquals> IntegerConst()|<SSEquals> <RESERVEDWORDNEW> <SSOpenBracket> IntegerConst() <SSCloseBracket>) <SSSemiColon>
}
void List (): {Token t;}
{
t =  <RESERVEDWORDLIST> (variable()) (<SSOpenBracket> IntegerConst() <SSCloseBracket> <SSEquals> IntegerConst()|<SSEquals>  <RESERVEDWORDNEW> <SSOpenBracket> IntegerConst() <SSCloseBracket>) <SSSemiColon>
}

// Garbage Code???
JAVACODE
void processVariableDecl(Token token, int index,
                         ArrayList<SymTabEntry> variableList) #void
{
    SymTabEntry variableId = symTabStack.enterLocal(token.image);
    variableId.setIndex(index);
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
    variableList.add(variableId);
  
}
